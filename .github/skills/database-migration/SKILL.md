---
name: database-migration
description: Safe database migration guide for modifying schemas, adding/removing columns, creating tables, and changing SQLModel fields. Use when modifying database models, altering table structure, adding foreign keys, changing field types, or updating database constraints in PostgreSQL with Alembic.
---

# Database Migration Skill

This skill guides you through creating safe, reversible database migrations using Alembic with SQLModel in this FastAPI application.

## When to Use This Skill

- Adding, removing, or modifying database columns
- Creating new database tables
- Changing field types, constraints, or validations
- Adding or removing indexes
- Modifying relationships or foreign keys
- Making any change to models in `backend/app/models.py`

## SQLModel Field Conventions

Follow these established patterns when defining fields:

### Primary Keys

Always use UUID primary keys with `default_factory`:

```python
id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
```

### Timestamps

Use `get_datetime_utc` helper with proper SQLAlchemy type:

```python
created_at: datetime | None = Field(
    default_factory=get_datetime_utc,
    sa_type=DateTime(timezone=True),  # type: ignore
)
```

**Reference**: `backend/app/models.py` lines 9-10, 52-55

### String Fields

Always specify `max_length` on string fields:

```python
title: str = Field(min_length=1, max_length=255)
email: EmailStr = Field(unique=True, index=True, max_length=255)
description: str | None = Field(default=None, max_length=255)
```

### Foreign Keys

Use descriptive naming and explicit cascade behavior:

```python
owner_id: uuid.UUID = Field(
    foreign_key="user.id", nullable=False, ondelete="CASCADE"
)
owner: User | None = Relationship(back_populates="items")
```

On the parent side:

```python
items: list["Item"] = Relationship(back_populates="owner", cascade_delete=True)
```

**Reference**: `backend/app/models.py` lines 93-96, 56

### Field Constraints

Use `Field()` for validation constraints:

```python
# Required field with length constraints
title: str = Field(min_length=1, max_length=255)

# Optional field
description: str | None = Field(default=None, max_length=255)

# Boolean with default
is_active: bool = True

# Unique and indexed
email: EmailStr = Field(unique=True, index=True, max_length=255)
```

**Reference**: `backend/app/models.py` throughout

## Generating Migrations

### Migration Generation Command

**CRITICAL**: Run migration generation **locally via uv**, NOT inside Docker:

```bash
cd backend && uv run alembic revision --autogenerate -m "Add user profile fields" && cd ..
```

**Why local execution?**
- Faster iteration cycle (no container rebuild)
- Direct access to source code changes
- Consistent with development workflow

### What Autogenerate Detects

Alembic autogenerate will detect:

- ✅ New tables and removed tables
- ✅ New columns and removed columns
- ✅ Changes to nullable status
- ✅ Changes to column types
- ✅ New indexes and constraints
- ❌ **Does NOT detect column renames** (appears as drop + add)
- ❌ **Does NOT detect table renames** (appears as drop + create)

## Critical Migration Audit Steps

**ALWAYS manually review and edit the generated migration file before applying it.**

### 1. Detect Rename-as-Drop+Add

Alembic cannot distinguish renames from drop+add operations. If you renamed a column or table:

**Bad (autogenerated)**:
```python
def upgrade() -> None:
    op.drop_column('user', 'full_name')
    op.add_column('user', sa.Column('display_name', sa.String(length=255), nullable=True))
```

**Good (manually refactored)**:
```python
def upgrade() -> None:
    op.alter_column('user', 'full_name', new_column_name='display_name')

def downgrade() -> None:
    op.alter_column('user', 'display_name', new_column_name='full_name')
```

For table renames:

```python
def upgrade() -> None:
    op.rename_table('old_table_name', 'new_table_name')

def downgrade() -> None:
    op.rename_table('new_table_name', 'old_table_name')
```

**Consequence of missing this**: Data loss in production when migration runs.

### 2. Nullable to Non-Nullable Changes

If making a nullable field non-nullable, you must handle existing NULL values first:

**Bad**:
```python
def upgrade() -> None:
    op.alter_column('user', 'full_name', nullable=False)
```

**Good**:
```python
def upgrade() -> None:
    # First, backfill NULL values with a default
    op.execute("UPDATE user SET full_name = 'Unknown' WHERE full_name IS NULL")
    # Then make the column non-nullable
    op.alter_column('user', 'full_name', nullable=False)

def downgrade() -> None:
    op.alter_column('user', 'full_name', nullable=True)
```

### 3. Verify Foreign Key Constraints

Check that foreign key definitions match your intent:

```python
# Verify the foreign key constraint includes CASCADE behavior if needed
op.create_foreign_key(
    'fk_item_owner',
    'item', 'user',
    ['owner_id'], ['id'],
    ondelete='CASCADE'  # Ensure this matches your model
)
```

### 4. Verify Index Creation

Ensure indexes are created for:
- Foreign key columns (performance)
- Frequently queried fields
- Fields used in WHERE clauses

```python
op.create_index(op.f('ix_user_email'), 'user', ['email'], unique=True)
```

### 5. Downgrade Function Verification

**Always verify the `downgrade()` function is correct and reversible**:

- For column additions → downgrade should drop the column
- For column renames → downgrade should reverse the rename
- For data migrations → downgrade should restore original data state (if possible)
- For non-reversible changes → add comment and consider raising an error

```python
def downgrade() -> None:
    # If downgrade would cause data loss, explicitly document it
    # raise NotImplementedError("Downgrade would result in data loss")
    op.drop_column('user', 'new_field')
```

## Migration File Location

Generated migrations are created in:

```
backend/app/alembic/versions/{revision}_{description}.py
```

**Always commit these files to version control.**

## Applying Migrations

### In Development (Docker)

```bash
# Apply all pending migrations
docker compose exec backend alembic upgrade head

# Or during startup (prestart.sh does this automatically)
cd backend && uv run bash scripts/prestart.sh && cd ..
```

### Rollback

```bash
# Rollback one migration
docker compose exec backend alembic downgrade -1

# Rollback to specific revision
docker compose exec backend alembic downgrade <revision_id>
```

### Check Current Status

```bash
# Show current revision
docker compose exec backend alembic current

# Show migration history
docker compose exec backend alembic history
```

**Reference**: `.github/copilot-instructions.md` lines 143-151

## Dependent Code Updates

After creating a migration, update these code areas:

### 1. CRUD Operations

Update `backend/app/crud.py` if CRUD functions reference changed fields:

```python
# If you renamed 'full_name' to 'display_name', update CRUD functions
def create_user(*, session: Session, user_create: UserCreate) -> User:
    db_obj = User.model_validate(
        user_create,
        update={"hashed_password": get_password_hash(user_create.password)}
    )
    # Ensure any field references are updated
```

**Reference**: `backend/app/crud.py`

### 2. API Routes

Update route handlers in `backend/app/api/routes/` if they reference changed fields:

```python
# Update any direct field references
@router.get("/{id}", response_model=UserPublic)
def read_user(session: SessionDep, id: uuid.UUID) -> Any:
    user = session.get(User, id)
    # Ensure returned data uses correct field names
```

### 3. Tests

Update tests in `backend/tests/` to use new field names or structures:

```python
def test_create_user(client: TestClient) -> None:
    data = {
        "email": "test@example.com",
        "display_name": "Test User",  # Updated field name
        "password": "password123"
    }
    # Update assertions
    assert content["display_name"] == data["display_name"]
```

### 4. Frontend Client Regeneration

**CRITICAL**: After backend model changes, regenerate the frontend OpenAPI client:

```bash
bash ./scripts/generate-client.sh
```

This ensures TypeScript types and API client methods match the new schema.

**Reference**: `scripts/generate-client.sh`, memory: frontend SDK generation

## Complex Migration Patterns

### Adding a Non-Nullable Field with Default

```python
def upgrade() -> None:
    # Add as nullable first
    op.add_column('user', sa.Column('status', sa.String(length=50), nullable=True))
    # Backfill with default value
    op.execute("UPDATE user SET status = 'active' WHERE status IS NULL")
    # Make non-nullable
    op.alter_column('user', 'status', nullable=False)

def downgrade() -> None:
    op.drop_column('user', 'status')
```

### Changing Column Type

```python
def upgrade() -> None:
    # Example: VARCHAR to TEXT (safe - expanding)
    op.alter_column('item', 'description',
                    type_=sa.Text(),
                    existing_type=sa.String(length=255))

def downgrade() -> None:
    # Downgrades may truncate data - be careful
    op.alter_column('item', 'description',
                    type_=sa.String(length=255),
                    existing_type=sa.Text())
```

### Adding a Foreign Key to Existing Data

```python
def upgrade() -> None:
    # Add column as nullable
    op.add_column('item', sa.Column('category_id', sa.UUID(), nullable=True))

    # Create default category for existing items
    op.execute("""
        INSERT INTO category (id, name)
        VALUES ('00000000-0000-0000-0000-000000000000', 'Uncategorized')
        ON CONFLICT DO NOTHING
    """)

    # Update existing rows
    op.execute("UPDATE item SET category_id = '00000000-0000-0000-0000-000000000000' WHERE category_id IS NULL")

    # Make non-nullable and add foreign key
    op.alter_column('item', 'category_id', nullable=False)
    op.create_foreign_key('fk_item_category', 'item', 'category', ['category_id'], ['id'])

def downgrade() -> None:
    op.drop_constraint('fk_item_category', 'item', type_='foreignkey')
    op.drop_column('item', 'category_id')
```

## Testing Migrations

### Test Migration Up

```bash
# Start fresh database
docker compose down -v
docker compose up -d db

# Apply all migrations
docker compose exec backend alembic upgrade head

# Verify schema
docker compose exec backend alembic current
```

### Test Migration Down (Rollback)

```bash
# Rollback the last migration
docker compose exec backend alembic downgrade -1

# Verify schema
docker compose exec backend alembic current

# Re-apply
docker compose exec backend alembic upgrade head
```

### Test with Real Data

```bash
# Start database with migrations
docker compose up -d db
cd backend && uv run bash scripts/prestart.sh && cd ..

# Run tests to ensure migrations don't break application
cd backend && uv run bash scripts/tests-start.sh && cd ..
```

## Common Pitfalls

- **Forgetting to audit autogenerated migrations** - Always manually review, especially for renames
- **Not handling existing NULL values** - Backfill before making fields non-nullable
- **Missing downgrade implementation** - Downgrades must reverse the upgrade operation
- **Forgetting to regenerate frontend client** - Run `bash ./scripts/generate-client.sh` after model changes
- **Applying migrations in Docker during development of migration** - Generate migrations locally with `uv run` for faster iteration
- **Not testing rollback** - Always verify `downgrade()` works before merging
- **Committing migrations without running tests** - Ensure ≥90% coverage is maintained

## Migration Workflow Summary

1. **Modify models** in `backend/app/models.py`
2. **Generate migration** locally: `cd backend && uv run alembic revision --autogenerate -m "Description" && cd ..`
3. **Audit migration file** in `backend/app/alembic/versions/`:
   - Check for renames (refactor drop+add to `op.alter_column` or `op.rename_table`)
   - Handle nullable changes (backfill first)
   - Verify foreign keys and indexes
   - Verify downgrade function
4. **Apply migration**: `docker compose exec backend alembic upgrade head`
5. **Update dependent code**:
   - `backend/app/crud.py`
   - `backend/app/api/routes/`
   - `backend/tests/`
6. **Regenerate frontend client**: `bash ./scripts/generate-client.sh`
7. **Run tests**: `cd backend && uv run bash scripts/tests-start.sh && cd ..`
8. **Test rollback**: `docker compose exec backend alembic downgrade -1` then re-upgrade
9. **Commit migration files** and updated code

## Checklist

- [ ] Modified SQLModel models in `backend/app/models.py` following field conventions
- [ ] Generated migration locally: `cd backend && uv run alembic revision --autogenerate -m "..." && cd ..`
- [ ] Manually audited migration file for rename detection
- [ ] Handled nullable-to-non-nullable changes with backfill
- [ ] Verified foreign key constraints include proper `ondelete` behavior
- [ ] Verified indexes are created for foreign keys and query fields
- [ ] Implemented and verified `downgrade()` function
- [ ] Applied migration: `docker compose exec backend alembic upgrade head`
- [ ] Updated CRUD operations in `backend/app/crud.py`
- [ ] Updated API routes in `backend/app/api/routes/`
- [ ] Updated tests in `backend/tests/`
- [ ] Regenerated frontend client: `bash ./scripts/generate-client.sh`
- [ ] Ran backend tests: `cd backend && uv run bash scripts/tests-start.sh`
- [ ] Tested rollback: `alembic downgrade -1` then `upgrade head`
- [ ] Committed migration files to version control
